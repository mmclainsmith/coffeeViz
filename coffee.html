<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Coffee</title>
<style>
    @import url("https://fonts.googleapis.com/css?family=Caveat");
    @import url("https://fonts.googleapis.com/css?family=Mali");

    :root {
      --darkest-brown: #4F2D0D;
      --dark-brown: #7E685A;
      --light-brown: #C2B9B0;
      --light-green: #fcfcf6;
      --green: #839153;
      --b-grey: #B7CEEC; /* water */
      --grey: gainsboro;
      --time: .2s;

      --color_consum: #4F2D0D;
      --color_export: #1F45FC;
      --color_prod: #348017;
      --color_stock: #990012;
    }

    body {
        background: var(--light-green);
        text-align: center;
        margin: 0;
        font-family: sans-serif;
    }

    h1 {
        font-family: "Mali";
        font-size: 64pt;
        color: var(--darkest-brown);
        margin: 0;
        text-shadow: var(--light-brown) 2px 2px;
    }

    h2, h3 {
        margin: 2px;
    }
    h2 {
        font-weight: 300;
    }
    h3 {
        color: var(--green);
        font-weight: lighter;
    }

    h4 {
    	color: black;
    	font-weight: 300;
    	margin: 5px;
    }

    h5 {
    	font-weight: 300;
    	margin: 5px;
    }

    svg {
        margin: 0 auto;
        display: block;
    }

    div {
        transition: var(--time);
    }

    a {
    	color: blue;
    }

    .graticule {
        fill: none;
        stroke: var(--darkest-brown);
        stroke-width: .5px;
        stroke-opacity: .5;
        stroke-dasharray: 1,1;
    }

    .graticule, .domain, .tick, .monthFilterButton rect {
        shape-rendering: crispEdges;
    }
    .country {
        stroke: var(--darkest-brown);
        stroke-width: .5px;
        stroke-opacity: .5;
        stroke-dasharray: 2,2;
        transition: var(--time) fill;
    }
    .coffee {
        stroke-dasharray: 1,0;
    }
    .unclickable {
        stroke-dasharray: 2,2;
        fill: var(--grey) !important;
    }

    .selected {
        stroke: black;
        stroke-width: 1px;
        stroke-opacity: 1;
    }

    .line {
    	fill: none;
    	stroke-width: 2px;
    }
    .line.consumption { stroke: var(--color_consum); }
    .line.export { stroke: var(--color_export); }
    .line.production { stroke: var(--color_prod); }
    .line.stock { stroke: var(--color_stock); }

    .bar {
    	fill: var(--dark-brown);
    }

    #main {
        background: var(--b-grey);
        border-top: 1px solid var(--dark-brown);
    }

    .slideBar {
        fill: var(--grey);
    }

    .monthFilterButton {
        display: inline-block;
        margin: 3px;
        padding: 5px;
        background-color: var(--light-brown);
        text-align: center;
        width: 5em;
        color: var(--dark-brown);
    }

    .down {
        background-color: var(--dark-brown);
        color: black;
    }

    #catBtns {
        display: flex;
        width: 980px;
        margin: 0 auto;
    }

    .catFilterButton {
    	flex-grow: 1;
        margin: 0;
        padding: 5px 0;
    	box-sizing: border-box;
        background-color: var(--light-brown);
        color: var(--dark-brown);
    }
    .catFilterButton.down {
    	background-color: var(--green);
        color: white;
    }
    .catFilterButton.down.consum { background-color: var(--color_consum); }
    .catFilterButton.down.export { background-color: var(--color_export); }
    .catFilterButton.down.prod { background-color: var(--color_prod); }
    .catFilterButton.down.stock { background-color: var(--color_stock); }

    .catFilterButton:hover{
        filter: brightness(90%);
    }

    .sliderBrush .selection {
        fill: var(--green);
        fill-opacity: 0.6;
        stroke: none;
    }

    .sliderBrush .handle--e, .sliderBrush .handle--w {
        fill: var(--dark-brown);
    }

    .sliderBrush .selection:active {
        cursor: grabbing;
    }

    #sliderAxis text {
        fill: var(--darkest-brown);
    }

    #sliderLines .tick line,  #sliderAxis .tick line {
        stroke: var(--dark-brown) !important;
        stroke-dasharray: 1,1;
        opacity: 0.7;
    }

    #sliderLines .domain, #sliderAxis .domain{
        stroke: none !important;
    }

    .monthFilterButton rect{
        fill: var(--grey);
        stroke: var(--dark-brown);
        stroke-width: .5px;
        stroke-opacity:
    }

    .monthFilterButton text{
        fill: var(--light-brown);
    }

    .monthFilterButton.down rect{
        fill: var(--light-brown);
    }

    .monthFilterButton.down text{
        fill: var(--dark-brown);
    }

    text.harvest {
        fill: var(--dark-brown);
    }

    #selected a {
        font-family: "Mali";
        font-weight: bold;
        display: inline-block;
        margin: 10px;
        color: black;
    }

    div.tooltip {
	  position: absolute;
	  text-align: center;
	  width: 100px;
	  height: 40px;
	  padding: 5px;
	  font: 12px sans-serif;
	  background: var(--grey);
	  border: 0px;
	  border-radius: 8px;
	  pointer-events: none;
	}

</style>
</head>

<body>
<h1> Coffee </h1>
<h2> A look at coffee production around the world </h2>
<h3> Lexie Kirsch and Morgan McLain-Smith </h3>
<h4> Note: Units are per thousand 60kg bag of unroasted coffee. </h4>

<div id = "catBtns">
    <div class ="catFilterButton down prod" id="prod"> Production </div>
    <div class ="catFilterButton consum" id="consum"> Consumption </div>
    <div class ="catFilterButton export" id="export"> Export </div>
    <div class ="catFilterButton stock" id="stock"> Opening Stock </div>
</div>
<svg width="980" height="270" id="main"></svg>

<svg id="slider"></svg>
<div id="selected"></div>
<svg id="lower"></svg>

<h5> Data sources: <a link href = "http://www.ico.org/">The International Coffee Organization</a> and <a link href = "https://www.kaggle.com/sbajew/exploring-coffee-production-and-consumption/data">Kaggle</a>.</h5>

<script src="js/d3.v4.min.js"></script>
<script src="js/topojson.v1.min.js"></script>

<script>
    let clean = s => s.replace(/\W/g, '');
    let svg = d3.select("#main"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    let catAbvs = {"Production":"prod", "Export":"exp", "Consumption":"consum", "Stock":"stock"};
    let month_abv = {"April":"apr", "July":"jul", "October":"oct"};
    let cats = ["prod", "consum", "export", "stock"];


    // This is horrifying, forgive me Mark.
    let startYear = 1998,
        endYear = 2004,
        cStat   = "prod";

    let dataByCountry = d3.nest();

    let projection = d3.geoMercator()
                        .scale(200)
                        .translate([ 422, height / 2])
                        .precision(0);

    let path = d3.geoPath().projection(projection);

    let graticule = d3.geoGraticule().step([5, 5]);

    svg.append("path")
        .datum(graticule)
        .attr("class", "graticule")
        .attr("d", path);

    svg.on("click", d => {
        selected = [];
        updatedSelected();
    });

    var div = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

/******************************************************************************
            Reading in data
 *****************************************************************************/
    d3.queue()
        .defer(d3.json, "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json")
        .defer(d3.csv, "ICO_CROP_DATA.csv", function(d){
            let data = {};
            data.country = d.COUNTRY;
            data.prod = +d.TOTAL_PRODUCTION;
            data.consum = +d.DOMESTIC_CONSUMPTION;
            data.export = +d.EXPORTABLE_PRODUCTION;
            data.stock = +d.GROSS_OPENING_STOCKS;
            data.year = +d.YEAR.slice(0,4);
            data.month = month_abv[d.MONTH];
            return data
         })
        .await(ready);

/******************************************************************************
            Initializing page
 *****************************************************************************/

    function ready(error, world, data) {
        if (error) throw error;

        dataByCountry = dataByCountry
            .key(function(d) { return d.country; })
            .object(data);

        // Draw countries
        svg.append("g")
            .selectAll(".country")
            .data(world.features)
            .enter().insert("path", ".graticule")
                .attr("class", "country")
                .attr("d", path)
                .classed("coffee", function(d) { return dataByCountry[d.properties.name]; })
                .classed("unclickable", function(d) { return !dataByCountry[d.properties.name]; })
                .transition().duration(6000);

        svg.selectAll(".coffee")
                .datum(function(d) { return {"name":d.properties.name, "data":dataByCountry[d.properties.name] } })
                .attr("id", d => clean(d.name) )
                .on("mouseover", function(d) {
                	if (!(d3.select(this).classed("unclickable"))) {
                		let min, max, rolledUp;
                		[min, max, rolledUp] = rollupByYears();

	                	div.transition().duration(200).style("opacity", 0.9);
	                	div.html("<b>"+ d.name + "</b>" + "<br/>" + d3.format(",d")(rolledUp[d.name][cStat]) + " bags")
	                		.style("left", (d3.event.pageX + 10) + "px")
	                		.style("top", (d3.event.pageY - 28) + "px");
                	}
                })
                .on("mouseout", function (d) {
                	div.transition().duration(500).style("opacity", 0);
                })
                .on("click", d => d3.event.stopPropagation() )
                .call(d3.drag()
                    .on("start", startCountrySelect)
                    .on("drag", dragCountrySelect)
                    .on("end", endCountrySelect));

        d3.selectAll(".catFilterButton")
            .on("click", function(d) {
                cStat = d3.select(this).attr("id");
                d3.selectAll(".catFilterButton").classed("down", false);
                d3.select(this).classed("down", true);
                colorMap();
            });

        makeSlider();
        makeMonthSelectors();
        colorMap();
    };

/*****************************************************************************
                Interactions Handlers
 *****************************************************************************/
    let selected = []

    function updatedSelected() {
        // Remove unclickable things from selected
        svg.selectAll(".coffee.unclickable")
            .each(function(d) {
                if (selected.includes(d.name)) {
                    selected.splice( selected.indexOf(d.name) );
                }
            }).classed("selected", false)

        if (selected.length == 1) {
            drawLineChart(selected[0]);
            // drawBarChart(selected[0]);
        } else if (selected.length > 1) { // TODO: add multiple selections
        	//drawBarChart(selected[0])
        } else {
            d3.select("#lower *").remove();
        }

     //Update Map
        d3.selectAll(".coffee:not(.unclickable)")
            .classed("selected", function(d) {
                return selected.includes(d.name);
            })
        d3.selectAll(".selected").raise();

     //Update bar
        d3.selectAll("#selected a").remove();
        d3.select("#selected").selectAll("a")
            .data(selected)
            .enter().append("a")
                .html(function(d){
                     return d;
                })
    }

    function startCountrySelect(d){
        d3.select("#main")
            .append("rect");
    }

    function dragCountrySelect(d){
        //console.log("dragging");
    }

    function endCountrySelect(d){
        select([d.name], d3.event.sourceEvent.shiftKey);
    }

    function clickCountrySelect(d) {
        d3.event.stopPropagation(); // Allows background clicking to deselect
        select([d.name], d3.event.sourceEvent.shiftKey);
    }

    function select(nameList, shift) {
        for (let i = 0; i < nameList.length; i++) {
            index = selected.indexOf(nameList[i]);
            if (shift) {
                if (index == -1) { //Id not in list
                    selected.push(nameList[i]);
                } else {
                    selected.splice(index);
                }
            } else { //Shift not selected
                if (index == -1) {
                    selected = nameList;
                } else {
                    selected = [];
                }
            }
        }
        updatedSelected()
    }

    function addStockDescription() {
    	d3.selectAll("h4").text("Note: Gross opening stock refers to the amount of coffee held at the beginning of a crop year to manage surplus.");
    }
    function removeStockDescription() {
    	d3.selectAll("h4").text("Note: Units are per thousand 60kg bag of unroasted coffee.");
    }


/*****************************  Month Filters ********************************/
    function makeMonthSelectors(){
        let margin = 20
        let monthScale = d3.scaleBand()
                            .domain(Object.keys(month_abv))
                            .range([height - margin - 90, height - margin])
                            .padding(.2);


        let monthBoxes = svg.selectAll(".monthFilterButton")
            .data(Object.entries(month_abv))
            .enter()
                .append("g")
                .attr("transform", d => `translate(${margin}, ${monthScale(d[0])})`)
                //.attr("height", monthScale.bandwidth())
                .attr("class", "monthFilterButton down")
                .on("click", function(d) {
                    btn = d3.select(this)
                    btn.classed("down", function(d){
                        return !d3.select(this).classed("down");
                    });
                    filterByMonth(d[1]);
                });

        svg.select(".monthFilterButton")
            .append("text")
            .attr("class", "harvest")
            .attr("dy", -10)
            .attr("text-anchor", "middle")
            .attr("dx", 40)
            .text("Harvest month");

        monthBoxes.append("rect")
                .attr("height", monthScale.bandwidth())
                .attr("width", 80)

        monthBoxes.append("text")
                .attr("dy", ".35em")
                .attr("dx", 40)
                .text(d => d[0])
                .attr("alignment-baseline","hanging")
                .attr("text-anchor", "middle");
    }

    function filterByMonth(month){
        svg.selectAll(".coffee")
            .classed("unclickable", function(d){
                let matchesMonth = d.data[0].month == month;
                if (!matchesMonth) { //Other month, stay the same
                    return d3.select(this).classed("unclickable")
                } else { // specified month, toggle
                    return !d3.select(this).classed("unclickable")
                }
            });
        updatedSelected();
        colorMap();
    }

/*******************************  Color Map **********************************/
    let color_consum = "#4F2D0D";
    let color_export = "#1F45FC";
    let color_prod = "#348017";
    let color_stock = "#990012";

    let mapColors = d3.scaleLinear().range(["#f7fcf5", "#254117"]);

    function colorMap(){
    	if (cStat == "consum") { mapColors = d3.scaleLinear().range(["#fee6ce", color_consum]); }
    	if (cStat == "export") { mapColors = d3.scaleLinear().range(["#deebf7", "#0000A0"]); }
    	if (cStat == "prod") { mapColors = d3.scaleLinear().range(["#f7fcf5", "#254117"]); }
    	if (cStat == "stock") {
            addStockDescription();
            mapColors = d3.scaleLinear().range(["#fff5f0", "#a50f15"]);
        }

    // function colorMap(){
    //
    //     let colorFunc = function(min, max){
    //
    //         let mapColors = d3.scaleLinear().range(["#C2B9B0", "#4F2D0D"]).domain([0,1]);
    //         let logScale = d3.scaleLog().range([0,1]).domain([min+.1e-6, max]);
    //         return function(d){return mapColors(logScale(d+.001))};
    //     }

        let min, max, rolledUp;

        [min, max, rolledUp] = rollupByYears();

        let colors = mapColors.domain([min[cStat], max[cStat]])
        svg.selectAll(".coffee")
            .style("fill", d => colors(rolledUp[d.name][cStat]) );
    }

/*****************************************************************************
                Chart Makers
 *****************************************************************************/

    function drawLineChart(countryName) {
        // Ref: https://bl.ocks.org/d3noob/4db972df5d7efc7d611255d1cc6f3c4f
        let data = dataByCountry[countryName];

        // dimensions of graph
        let margin = {top: 20, right: 105, bottom: 30, left: 70},
                      width = 980 - margin.left - margin.right,
                      height = 300 - margin.top - margin.bottom;

        // axis ranges
        let max = d3.nest()
                    .rollup(d => {

                        return [
                        d3.max(d, d2 => d2["prod"]),
                        d3.max(d, d2 => d2["consum"]),
                        d3.max(d, d2 => d2["export"]),
                        d3.max(d, d2 => d2["stock"]),
                    ]})
                    .object(data)


        let x = d3.scaleLinear().domain([1990, 2017]).range([0, width]);
        let y = d3.scaleLinear().domain([0, d3.max(max)]).range([height, 0]);

        // lines
        let consumptionLine = d3.line()
            .x(function(d) { return x(d.year); })
            .y(function(d) { return y(d.consum); });

        let productionLine = d3.line()
        	.x(function(d) { return x(d.year); })
        	.y(function(d) { return y(d.prod); });

        let exportLine = d3.line()
        	.x(function(d) { return x(d.year); })
        	.y(function(d) { return y(d.export); });

        let stockLine = d3.line()
        	.x(function(d) { return x(d.year); })
        	.y(function(d) { return y(d.stock); });

        // append svg
        let svg2 = d3.select("#lower");
        svg2.selectAll("*").remove();

        let graph = svg2.attr("width", width + margin.left + margin.right)
            .attr("height", 1000)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // add the lines!
        for (let i = 0; i < 4; i++) {
        	var linetype = ["line consumption", "line production", "line export", "line stock"];
        	var line = [consumptionLine, productionLine, exportLine, stockLine];
        	graph.append("path")
	            .data([data])
	            .attr("class", linetype[i])
	            .attr("d", line[i]);
        }

        // add X axis
        graph.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x).tickFormat(d3.format("d")));

        // label X axis
        graph.append("text")
        	.attr("transform", "translate(" + (width/2 + 18) + "," + (height + margin.top + 20) + ")")
        	.style("text-anchor", "middle")
        	.text("Year");

        // add Y axis
        graph.append("g")
            .call(d3.axisLeft(y));

        // label Y axis
        graph.append("text")
        	.attr("transform", "rotate(-90)")
        	.attr("y", 0 - margin.left)
        	.attr("x", 0 - (height / 2))
        	.attr("dy", "1em")
        	.style("text-anchor", "middle")
        	.text("Thousand 60kg bags of unroasted coffee");

        // add legend
        for (let i = 0; i < 4; i++) {
        	var linetypes = ["Production", "Consumption", "Export", "Stock"];
        	var colors = [color_prod, color_consum, color_export, color_stock];
        	graph.append("rect")
				.attr("transform", "translate(" + (width + 45) + "," + (70 + 70*(i-1)) + ")")
				.attr("width", 20)
				.attr("height", 20)
				.attr("fill", colors[i]);
			graph.append("text")
	        	.attr("transform", "translate(" + (width + 55) + "," + (110 + 70*(i-1)) + ")")
	        	.style("text-anchor", "middle")
	        	.text(linetypes[i]);
        }

        return
    }

    function drawBarChart(countryName) {
        let data = dataByCountry[countryName];

        // dimensions of graph
        let margin = {top: 20, right: 100, bottom: 30, left: 70},
                      width = 960 - margin.left - margin.right,
                      height = 300 - margin.top - margin.bottom;
        // axis ranges
        let x = d3.scaleBand().padding(0.1).domain([0, 10]).range([0, width]); //TODO: change domain to number of countries
        let y = d3.scaleLinear().domain([0, d3.max(data, function(d) { return d.prod; })]).range([height, 0]);

        let svg2 = d3.select("#lower")
        svg2.selectAll("*").remove()

        svg2.append("text")
        	.attr("transform", "translate(" + (width/2) + "," + (margin.top) + ")")
        	.style("text-anchor", "middle")
        	.text("Production in 2017");

        svg2.selectAll(".bar").data([data])
        	.enter().append("rect")
        		.attr("class", "bar")
        		.attr("x", function(d) { return x(d[27].country); })
        		.attr("width", x.bandwidth())
        		.attr("y", function(d) { return y(d[27].prod); })
        		.attr("height", function(d) { return height - y(d[27].prod); });

        let graph = svg2.attr("width", width + margin.left + margin.right)
            .attr("height", 1000)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // add X axis
        graph.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
        graph.append("text")
        	.attr("transform", "translate(" + (width/2) + "," + (height + margin.top + 20) + ")")
        	.style("text-anchor", "middle")
        	.text("Country");

        // add Y axis
        graph.append("g")
            .call(d3.axisLeft(y));
        graph.append("text")
        	.attr("transform", "rotate(-90)")
        	.attr("y", 0 - margin.left)
        	.attr("x", 0 - (height / 2))
        	.attr("dy", "1em")
        	.style("text-anchor", "middle")
        	.text("Production per thousand 60kg bags of unroasted coffee");
    }



/*****************************************************************************
                Time Slider
 *****************************************************************************/
    function makeSlider() {
        let slider = {  svg: d3.select("#slider"),
                        height: 70,
                        mTop: 20,
                        mLeft: 20 }

        let yearScale = d3.scaleLinear()
                            .domain([1990, 2017])
                            .range([0, width - 1]);

        // Allowed sliding area
        slider.svg.attr("width", width + 2 * slider.mLeft)
            .attr("height", slider.height)
            .append("rect")
                .attr("class", "slideBar")
                .attr("width", width)
                .attr("height", slider.height - slider.mTop * 2)
                .attr("transform", `translate(${slider.mLeft}, ${slider.mTop})`);

        //Numbered tick marks
        slider.svg.append("g")
            .attr("id", "sliderAxis")
            .attr("transform", `translate(${slider.mLeft}, ${slider.height - slider.mTop})`)
            .call(d3.axisBottom(yearScale)
                    .tickSize(10)
                    .tickFormat(d3.format("d")));

        // Unlabelled ticks
        slider.svg.append("g")
            .attr("id", "sliderLines")
            .attr("transform", `translate(${slider.mLeft}, ${slider.mTop})`)
            .call(d3.axisBottom(yearScale)
                    .tickSize(slider.height - slider.mTop * 2)
                    .ticks(20)
                    .tickFormat(function() { return null; })
                );

        let sliderBrush = d3.brushX()
                .extent([[yearScale.range()[0], 0],
                         [yearScale.range()[1], slider.height - 2 * slider.mTop]])
                .on("end", sliderBrushEnded)
                .on("brush", sliderBrushing);

        slider.svg.append("g")
            .attr("class", "sliderBrush")
            .attr("transform", `translate(${slider.mLeft}, ${slider.mTop})`)
            .call(sliderBrush)
            .call(sliderBrush.move, [startYear, endYear].map(yearScale));


        function sliderBrushEnded() {
            if (!d3.event.sourceEvent) return; // Only transition after input.
            if (!d3.event.selection) return; // Ignore empty selections.
            var d0 = d3.event.selection.map(yearScale.invert),
                d1 = d0.map(Math.round);

            d3.select(this).transition().call(d3.event.target.move, d1.map(yearScale));

            startYear = d1[0];
            endYear = d1[1];
            colorMap();
        }

        function sliderBrushing() { // Update while sliding
            var d0 = d3.event.selection.map(yearScale.invert),
                d1 = d0.map(Math.round);

            startYear = d1[0];
            endYear = d1[1];
            colorMap();
        }
    }

    function rollupByYears() {
        let rolledUp = {};
        let min = {};
        let max = {};

        if (startYear == endYear) {
            for (let country in dataByCountry){
                let countryData = {};
                cats.forEach(c => {countryData[c] = 0});
                rolledUp[country] = countryData;
            }
            cats.forEach(c => {min[c] = 0});
            cats.forEach(c => {max[c] = 1});
        } else {
            let sumF = (s, d) => d3.sum(d, d2 => d2[s]);
            let minF = (s, d) => d3.min(d, d2 => d2[1][s]);
            let maxF = (s, d) => d3.max(d, d2 => d2[1][s]);

            for (let country in dataByCountry){
                let id = `path#${clean(country)}`;
                let visible = !d3.select(id).classed("unclickable");
                rolledUp[country] =  d3.nest()
                        .rollup(d => {
                            let data = {}
                            cats.forEach( s => {
                                data[s] = sumF(s, d)
                            });
                            return data;
                        }).entries(
                            dataByCountry[country].filter( d => (startYear <= d.year && d.year < endYear && visible))
                        );
            }

            let rollup = (func) => {
                return d3.nest()
                    .rollup(d => {
                    let data = {}
                        cats.forEach( s => { data[s] = func(s, d) });
                    return data
                }).entries(Object.entries(rolledUp));
            }

            max = rollup(maxF);
            min = rollup(minF)
        }
        console.log( min, max, rolledUp )
        return [min, max, rolledUp]
    }

</script>
</body>
</html>
